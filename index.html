<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>媒体分析工具</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: #f5f5f5;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            display: flex;
            min-height: 100vh;
            background: #f5f5f5;
        }


        .upload-area {
            padding: 40px;
            text-align: center;
            border-bottom: 2px dashed #e0e0e0;
        }

        .upload-box {
            border: 2px dashed #ccc;
            border-radius: 8px;
            padding: 60px 20px;
            background: #fafafa;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .upload-box:hover {
            border-color: #666;
            background: #f0f0f0;
        }

        .upload-box.dragover {
            border-color: #333;
            background: #e8e8e8;
        }

        .upload-icon {
            font-size: 3em;
            margin-bottom: 20px;
            color: #999;
            font-weight: 300;
        }

        .upload-text {
            font-size: 1.2em;
            color: #333;
            margin-bottom: 10px;
            font-weight: 600;
        }

        .upload-hint {
            color: #999;
            font-size: 0.9em;
        }

        #fileInput {
            display: none;
        }

        .preview-section {
            padding: 40px;
            display: none;
        }

        .preview-section.active {
            display: block;
        }

        .preview-image {
            text-align: center;
            margin-bottom: 30px;
        }

        .preview-image img {
            max-width: 100%;
            max-height: 400px;
            border-radius: 4px;
            border: 1px solid #ddd;
        }

        .info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-top: 30px;
        }

        .info-card {
            background: #fafafa;
            border-radius: 4px;
            padding: 20px;
            border-left: 3px solid #666;
            border: 1px solid #e0e0e0;
        }

        .info-label {
            font-size: 0.9em;
            color: #666;
            margin-bottom: 8px;
            font-weight: 500;
        }

        .info-value {
            font-size: 1.3em;
            color: #333;
            font-weight: 600;
        }

        .btn-reset {
            display: block;
            margin: 30px auto 0;
            padding: 12px 30px;
            background: #333;
            color: white;
            border: none;
            border-radius: 4px;
            font-size: 1em;
            cursor: pointer;
            transition: background 0.2s ease;
        }

        .btn-reset:hover {
            background: #555;
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: #666;
            font-size: 1.2em;
        }

        .error {
            background: #fee;
            color: #c33;
            padding: 15px;
            border-radius: 10px;
            margin: 20px;
            text-align: center;
        }

        /* 左侧菜单 */
        .sidebar {
            width: 200px;
            background: #333;
            color: white;
            padding: 20px 0;
            flex-shrink: 0;
        }

        .sidebar-header {
            padding: 20px;
            border-bottom: 1px solid #555;
        }

        .sidebar-header h1 {
            font-size: 1.5em;
            margin-bottom: 5px;
        }

        .sidebar-header p {
            font-size: 0.9em;
            opacity: 0.8;
        }

        .menu {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .menu-item {
            padding: 15px 20px;
            cursor: pointer;
            transition: all 0.2s ease;
            border-left: 3px solid transparent;
        }

        .menu-item:hover {
            background: #444;
        }

        .menu-item.active {
            background: #444;
            border-left-color: white;
            font-weight: 600;
        }

        /* 右侧内容区 */
        .content-area {
            flex: 1;
            background: white;
            overflow-y: auto;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        /* 音频左右布局 */
        .audio-layout {
            display: flex;
            gap: 30px;
            margin-top: 20px;
        }

        .audio-left {
            flex: 1;
            min-width: 0;
        }

        .audio-right {
            flex: 1;
            min-width: 0;
        }

        /* 音频波形图 */
        .waveform-container {
            margin-bottom: 20px;
            padding: 20px;
            background: #fafafa;
            border-radius: 4px;
            border: 1px solid #e0e0e0;
        }

        .waveform-title {
            font-size: 1.1em;
            font-weight: 600;
            margin-bottom: 15px;
            color: #333;
        }

        .waveform-canvas {
            width: 100%;
            height: 200px;
            background: white;
            border: 1px solid #ddd;
            border-radius: 4px;
            display: block;
        }

        /* 音频播放器 */
        .audio-player {
            margin-bottom: 20px;
            text-align: center;
        }

        .audio-player audio {
            width: 100%;
        }

        @media (max-width: 768px) {
            .container {
                flex-direction: column;
            }

            .sidebar {
                width: 100%;
                padding: 10px 0;
            }

            .menu {
                display: flex;
            }

            .menu-item {
                flex: 1;
                text-align: center;
                border-left: none;
                border-bottom: 3px solid transparent;
            }

            .menu-item.active {
                border-left: none;
                border-bottom-color: white;
            }

            .audio-layout {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- 左侧菜单 -->
        <div class="sidebar">
            <div class="sidebar-header">
                <h1>媒体分析</h1>
                <p>分析工具</p>
            </div>
            <ul class="menu">
                <li class="menu-item active" onclick="switchTab('image')">图片分析</li>
                <li class="menu-item" onclick="switchTab('audio')">音频分析</li>
            </ul>
        </div>

        <!-- 右侧内容区 -->
        <div class="content-area">
        <!-- 图片分析Tab -->
        <div class="tab-content active" id="imageTab">
            <div class="upload-area">
                <div class="upload-box" id="imageUploadBox">
                    <div class="upload-icon">+</div>
                    <div class="upload-text">点击或拖拽图片到这里</div>
                    <div class="upload-hint">支持 JPG、PNG、GIF、WebP、BMP 等格式</div>
                </div>
                <input type="file" id="imageFileInput" accept="image/*">
            </div>

            <div class="preview-section" id="imagePreviewSection">
                <div class="preview-image" id="previewImage"></div>
                <div class="info-grid" id="imageInfoGrid"></div>
                <button class="btn-reset" onclick="resetImageAnalysis()">重新分析</button>
            </div>
        </div>

        <!-- 音频分析Tab -->
        <div class="tab-content" id="audioTab">
            <div class="upload-area">
                <div class="upload-box" id="audioUploadBox">
                    <div class="upload-icon">+</div>
                    <div class="upload-text">点击或拖拽音频文件到这里</div>
                    <div class="upload-hint">支持 MP3、WAV、OGG、AAC、M4A 等格式</div>
                </div>
                <input type="file" id="audioFileInput" accept="audio/*">
            </div>

            <div class="preview-section" id="audioPreviewSection">
                <div class="audio-layout">
                    <div class="audio-left">
                        <div class="audio-player" id="audioPlayer"></div>
                        <div class="waveform-container" id="waveformContainer">
                            <div class="waveform-title">波形图</div>
                            <canvas class="waveform-canvas" id="waveformCanvas"></canvas>
                        </div>
                    </div>
                    <div class="audio-right">
                        <div class="info-grid" id="audioInfoGrid"></div>
                    </div>
                </div>
                <button class="btn-reset" onclick="resetAudioAnalysis()">重新分析</button>
            </div>
        </div>
        </div>
    </div>

    <script>
        // Tab切换
        function switchTab(tabName) {
            // 更新菜单项状态
            document.querySelectorAll('.menu-item').forEach((item, index) => {
                item.classList.remove('active');
                if ((tabName === 'image' && index === 0) || (tabName === 'audio' && index === 1)) {
                    item.classList.add('active');
                }
            });

            // 更新tab内容
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });
            document.getElementById(tabName + 'Tab').classList.add('active');

            // 重置当前tab
            if (tabName === 'image') {
                resetImageAnalysis();
            } else {
                resetAudioAnalysis();
            }
        }

        // ========== 图片分析部分 ==========
        const imageUploadBox = document.getElementById('imageUploadBox');
        const imageFileInput = document.getElementById('imageFileInput');
        const imagePreviewSection = document.getElementById('imagePreviewSection');
        const previewImage = document.getElementById('previewImage');
        const imageInfoGrid = document.getElementById('imageInfoGrid');

        // 图片文件输入事件
        imageUploadBox.addEventListener('click', () => imageFileInput.click());
        imageFileInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                analyzeImage(e.target.files[0]);
            }
        });

        // 图片拖拽事件
        imageUploadBox.addEventListener('dragover', (e) => {
            e.preventDefault();
            imageUploadBox.classList.add('dragover');
        });

        imageUploadBox.addEventListener('dragleave', () => {
            imageUploadBox.classList.remove('dragover');
        });

        imageUploadBox.addEventListener('drop', (e) => {
            e.preventDefault();
            imageUploadBox.classList.remove('dragover');
            if (e.dataTransfer.files.length > 0) {
                analyzeImage(e.dataTransfer.files[0]);
            }
        });

        /**
         * 分析图片信息
         * @param {File} file - 图片文件对象
         */
        async function analyzeImage(file) {
            try {
                // 显示加载状态
                imagePreviewSection.classList.add('active');
                previewImage.innerHTML = '<div class="loading">正在分析图片...</div>';
                imageInfoGrid.innerHTML = '';

                // 创建图片对象
                const img = new Image();
                const reader = new FileReader();

                // 读取文件
                reader.onload = async (e) => {
                    img.src = e.target.result;

                    img.onload = async () => {
                        // 显示预览图
                        previewImage.innerHTML = `<img src="${e.target.result}" alt="预览图">`;

                        // 获取基本信息
                        const fileType = getFileType(file.name, file.type);
                        const fileSize = formatFileSize(file.size);
                        const width = img.naturalWidth;
                        const height = img.naturalHeight;
                        const aspectRatio = (width / height).toFixed(2);

                        // 获取Canvas信息（用于位深和颜色模式）
                        const canvas = document.createElement('canvas');
                        const ctx = canvas.getContext('2d');
                        canvas.width = width;
                        canvas.height = height;
                        ctx.drawImage(img, 0, 0);

                        // 获取位深和颜色模式
                        const imageData = ctx.getImageData(0, 0, width, height);
                        const bitDepth = getBitDepth(imageData);
                        const colorMode = getColorMode(imageData);

                        // 获取压缩算法
                        const compression = await getCompressionAlgorithm(file, fileType);

                        // 获取其他信息
                        const pixelCount = (width * height).toLocaleString();
                        const fileFormat = fileType.toUpperCase();

                // 显示信息
                displayImageInfo([
                    { label: '文件类型', value: fileFormat },
                    { label: '文件大小', value: fileSize },
                    { label: '宽度', value: `${width} px` },
                    { label: '高度', value: `${height} px` },
                    { label: '宽高比', value: aspectRatio },
                    { label: '像素总数', value: pixelCount },
                    { label: '位深', value: bitDepth },
                    { label: '颜色模式', value: colorMode },
                    { label: '压缩算法', value: compression }
                ]);
                    };

                    img.onerror = () => {
                        showImageError('无法加载图片，请确保文件格式正确');
                    };
                };

                reader.readAsDataURL(file);
            } catch (error) {
                showImageError('分析图片时出错: ' + error.message);
            }
        }

        /**
         * 获取文件类型
         */
        function getFileType(fileName, mimeType) {
            const extension = fileName.split('.').pop().toLowerCase();
            const typeMap = {
                'jpg': 'JPEG',
                'jpeg': 'JPEG',
                'png': 'PNG',
                'gif': 'GIF',
                'webp': 'WebP',
                'bmp': 'BMP',
                'svg': 'SVG',
                'ico': 'ICO',
                'tiff': 'TIFF',
                'tif': 'TIFF'
            };
            return typeMap[extension] || mimeType || '未知';
        }

        /**
         * 格式化文件大小
         */
        function formatFileSize(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return Math.round(bytes / Math.pow(k, i) * 100) / 100 + ' ' + sizes[i];
        }

        /**
         * 获取位深
         */
        function getBitDepth(imageData) {
            // Canvas ImageData 通常是 RGBA，每个通道8位，总共32位
            // 但实际位深取决于原始图片格式
            // 这里我们检测是否有透明度通道
            const hasAlpha = imageData.data.length === imageData.width * imageData.height * 4;
            
            // 检查是否所有alpha值都是255（不透明）
            let allOpaque = true;
            for (let i = 3; i < imageData.data.length; i += 4) {
                if (imageData.data[i] !== 255) {
                    allOpaque = false;
                    break;
                }
            }

            if (hasAlpha && !allOpaque) {
                return '32位 (RGBA)';
            } else {
                return '24位 (RGB)';
            }
        }

        /**
         * 获取颜色模式
         */
        function getColorMode(imageData) {
            const data = imageData.data;
            const pixelCount = imageData.width * imageData.height;
            
            // 检查是否为灰度图
            let isGrayscale = true;
            const grayValues = new Set(); // 用于统计不同的灰度值
            const colorSet = new Set(); // 用于统计所有不同的颜色
            
            // 采样检查（对于小图片全扫描，大图片采样）
            // 抖动检测需要足够的采样才能准确
            const sampleSize = pixelCount < 100000 ? pixelCount : Math.min(100000, pixelCount);
            const step = Math.max(1, Math.floor(pixelCount / sampleSize));
            
            for (let i = 0; i < data.length; i += 4 * step) {
                const r = data[i];
                const g = data[i + 1];
                const b = data[i + 2];
                
                // 记录颜色（量化到8位以减少内存）
                const colorKey = `${Math.floor(r)},${Math.floor(g)},${Math.floor(b)}`;
                colorSet.add(colorKey);
                
                if (r !== g || g !== b) {
                    isGrayscale = false;
                } else {
                    grayValues.add(Math.floor(r)); // 记录灰度值
                }
            }

            // 检查是否有透明度
            let hasAlpha = false;
            for (let i = 3; i < data.length; i += 4 * step) {
                if (data[i] < 255) {
                    hasAlpha = true;
                    break;
                }
            }

            // 检测抖动算法
            const ditherInfo = detectDithering(colorSet, isGrayscale);
            
            if (isGrayscale) {
                // 检测灰度级别（位数）
                const grayLevel = getGrayLevel(grayValues);
                const alphaText = hasAlpha ? ' + Alpha' : '';
                const ditherText = ditherInfo ? ` (${ditherInfo})` : '';
                return `灰度${grayLevel}${alphaText}${ditherText}`;
            } else {
                const alphaText = hasAlpha ? ' + Alpha' : '';
                const ditherText = ditherInfo ? ` (${ditherInfo})` : '';
                return `RGB${alphaText}${ditherText}`;
            }
        }

        /**
         * 检测抖动算法
         * @param {Set} colorSet - 颜色集合
         * @param {boolean} isGrayscale - 是否为灰度图
         * @returns {string|null} 抖动类型
         */
        function detectDithering(colorSet, isGrayscale) {
            const colorCount = colorSet.size;
            
            // 如果颜色数量很少，很可能是抖动
            // 常见的抖动类型：2色、4色、6色、8色、16色等
            if (colorCount === 2) {
                return '2色抖动';
            } else if (colorCount === 3 || colorCount === 4) {
                return '4色抖动';
            } else if (colorCount === 5 || colorCount === 6) {
                return '6色抖动';
            } else if (colorCount === 7 || colorCount === 8) {
                return '8色抖动';
            } else if (colorCount >= 9 && colorCount <= 16) {
                return '16色抖动';
            } else if (colorCount >= 17 && colorCount <= 32) {
                return '32色抖动';
            } else if (colorCount >= 33 && colorCount <= 64) {
                return '64色抖动';
            } else if (colorCount >= 65 && colorCount <= 128) {
                return '128色抖动';
            } else if (colorCount >= 129 && colorCount <= 256) {
                // 256色可能是调色板模式或抖动
                return '256色 (可能抖动/调色板)';
            }
            
            // 如果颜色数量很多（>256），通常不是抖动
            // 但某些高级抖动算法可能会产生更多颜色
            // 这里我们只返回null，表示未检测到明显的抖动
            return null;
        }

        /**
         * 获取灰度级别（位数）
         * 灰度级别表示每个像素用多少位来表示灰度值
         * 1位=2级(黑白), 4位=16级, 8位=256级, 16位=65536级
         */
        function getGrayLevel(grayValues) {
            const uniqueCount = grayValues.size;
            
            if (uniqueCount <= 2) {
                return ' (1位, 2级)';
            } else if (uniqueCount <= 4) {
                return ' (2位, 4级)';
            } else if (uniqueCount <= 16) {
                return ' (4位, 16级)';
            } else if (uniqueCount <= 32) {
                return ' (5位, 32级)';
            } else if (uniqueCount <= 64) {
                return ' (6位, 64级)';
            } else if (uniqueCount <= 128) {
                return ' (7位, 128级)';
            } else if (uniqueCount <= 256) {
                return ' (8位, 256级)';
            } else {
                // 理论上Canvas最多8位，但显示实际级别
                return ` (实际使用 ${uniqueCount} 级)`;
            }
        }

        /**
         * 获取压缩算法
         */
        async function getCompressionAlgorithm(file, fileType) {
            const compressionMap = {
                'JPEG': 'JPEG压缩 (有损)',
                'PNG': 'PNG压缩 (无损)',
                'GIF': 'LZW压缩 (无损)',
                'WebP': 'WebP压缩 (有损/无损)',
                'BMP': '无压缩 (未压缩)',
                'SVG': '文本压缩 (矢量)',
                'TIFF': '多种压缩算法支持'
            };

            // 尝试读取文件头获取更准确的信息
            const buffer = await file.slice(0, 12).arrayBuffer();
            const bytes = new Uint8Array(buffer);

            // JPEG文件头: FF D8 FF
            if (bytes[0] === 0xFF && bytes[1] === 0xD8 && bytes[2] === 0xFF) {
                return 'JPEG压缩 (有损)';
            }
            // PNG文件头: 89 50 4E 47
            if (bytes[0] === 0x89 && bytes[1] === 0x50 && bytes[2] === 0x4E && bytes[3] === 0x47) {
                // 检查PNG压缩方法（通常在IHDR之后）
                return 'PNG压缩 (无损, Deflate)';
            }
            // GIF文件头: 47 49 46 38
            if (bytes[0] === 0x47 && bytes[1] === 0x49 && bytes[2] === 0x46 && bytes[3] === 0x38) {
                return 'LZW压缩 (无损)';
            }
            // WebP文件头: RIFF...WEBP
            if (bytes[0] === 0x52 && bytes[1] === 0x49 && bytes[2] === 0x46 && bytes[3] === 0x46) {
                // 检查是否包含VP8或VP8L
                const webpHeader = await file.slice(8, 16).arrayBuffer();
                const webpBytes = new Uint8Array(webpHeader);
                const headerStr = String.fromCharCode(...webpBytes);
                if (headerStr.includes('VP8L')) {
                    return 'WebP压缩 (无损, VP8L)';
                } else if (headerStr.includes('VP8 ')) {
                    return 'WebP压缩 (有损, VP8)';
                }
                return 'WebP压缩';
            }
            // BMP文件头: 42 4D
            if (bytes[0] === 0x42 && bytes[1] === 0x4D) {
                return '无压缩 (未压缩)';
            }

            return compressionMap[fileType] || '未知';
        }

        /**
         * 显示图片信息卡片
         */
        function displayImageInfo(infoArray) {
            imageInfoGrid.innerHTML = infoArray.map(info => `
                <div class="info-card">
                    <div class="info-label">${info.label}</div>
                    <div class="info-value">${info.value}</div>
                </div>
            `).join('');
        }

        /**
         * 显示图片错误信息
         */
        function showImageError(message) {
            previewImage.innerHTML = `<div class="error">${message}</div>`;
        }

        /**
         * 重置图片分析
         */
        function resetImageAnalysis() {
            imagePreviewSection.classList.remove('active');
            imageFileInput.value = '';
            previewImage.innerHTML = '';
            imageInfoGrid.innerHTML = '';
        }

        // ========== 音频分析部分 ==========
        const audioUploadBox = document.getElementById('audioUploadBox');
        const audioFileInput = document.getElementById('audioFileInput');
        const audioPreviewSection = document.getElementById('audioPreviewSection');
        const audioInfoGrid = document.getElementById('audioInfoGrid');
        const audioPlayer = document.getElementById('audioPlayer');
        const waveformCanvas = document.getElementById('waveformCanvas');
        const waveformContainer = document.getElementById('waveformContainer');

        // 音频文件输入事件
        audioUploadBox.addEventListener('click', () => audioFileInput.click());
        audioFileInput.addEventListener('change', (e) => {
            if (e.target.files.length > 0) {
                analyzeAudio(e.target.files[0]);
            }
        });

        // 音频拖拽事件
        audioUploadBox.addEventListener('dragover', (e) => {
            e.preventDefault();
            audioUploadBox.classList.add('dragover');
        });

        audioUploadBox.addEventListener('dragleave', () => {
            audioUploadBox.classList.remove('dragover');
        });

        audioUploadBox.addEventListener('drop', (e) => {
            e.preventDefault();
            audioUploadBox.classList.remove('dragover');
            if (e.dataTransfer.files.length > 0) {
                analyzeAudio(e.dataTransfer.files[0]);
            }
        });

        /**
         * 分析音频信息
         * @param {File} file - 音频文件对象
         */
        async function analyzeAudio(file) {
            try {
                audioPreviewSection.classList.add('active');
                audioInfoGrid.innerHTML = '<div class="loading">正在分析音频...</div>';
                audioPlayer.innerHTML = '';
                waveformContainer.style.display = 'none';

                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const arrayBuffer = await file.arrayBuffer();
                const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);

                // 获取音频基本信息
                const fileType = getAudioFileType(file.name, file.type);
                const fileSize = formatFileSize(file.size);
                const duration = audioBuffer.duration;
                const sampleRate = audioBuffer.sampleRate;
                const numberOfChannels = audioBuffer.numberOfChannels;
                const length = audioBuffer.length;
                const bitDepth = getAudioBitDepth(audioBuffer);
                
                // 计算频率信息
                const frequencyData = getFrequencyData(audioBuffer, sampleRate);
                const dominantFreq = frequencyData.dominantFreq;

                // 创建音频播放器
                const audioUrl = URL.createObjectURL(file);
                audioPlayer.innerHTML = `<audio controls src="${audioUrl}"></audio>`;

                // 显示信息
                displayAudioInfo([
                    { label: '文件类型', value: fileType },
                    { label: '文件大小', value: fileSize },
                    { label: '时长', value: formatDuration(duration) },
                    { label: '采样率', value: `${sampleRate} Hz` },
                    { label: '位深', value: bitDepth },
                    { label: '声道数', value: numberOfChannels === 1 ? '单声道' : numberOfChannels === 2 ? '立体声' : `${numberOfChannels} 声道` },
                    { label: '采样点数', value: length.toLocaleString() },
                    { label: '主要频率', value: dominantFreq ? `${dominantFreq.toFixed(2)} Hz` : '无法检测' },
                    { label: '频率范围', value: `${frequencyData.minFreq.toFixed(0)} - ${frequencyData.maxFreq.toFixed(0)} Hz` },
                    { label: '奈奎斯特频率', value: `${frequencyData.nyquist.toFixed(0)} Hz` }
                ]);

                // 显示波形图容器并绘制
                waveformContainer.style.display = 'block';
                // 延迟绘制，确保容器已显示
                setTimeout(() => {
                    drawWaveform(audioBuffer);
                }, 100);
            } catch (error) {
                showAudioError('分析音频时出错: ' + error.message);
            }
        }

        /**
         * 获取音频文件类型
         */
        function getAudioFileType(fileName, mimeType) {
            const extension = fileName.split('.').pop().toLowerCase();
            const typeMap = {
                'mp3': 'MP3',
                'wav': 'WAV',
                'ogg': 'OGG',
                'aac': 'AAC',
                'm4a': 'M4A',
                'flac': 'FLAC',
                'wma': 'WMA',
                'opus': 'Opus'
            };
            return typeMap[extension] || mimeType || '未知';
        }

        /**
         * 获取音频位深
         */
        function getAudioBitDepth(audioBuffer) {
            // Web Audio API通常使用32位浮点数，但实际位深取决于原始文件
            // 这里我们根据数据范围来估算
            const channelData = audioBuffer.getChannelData(0);
            let maxValue = 0;
            let minValue = 0;
            
            for (let i = 0; i < Math.min(10000, channelData.length); i++) {
                const value = Math.abs(channelData[i]);
                if (value > maxValue) maxValue = value;
                if (value < minValue) minValue = value;
            }

            // 如果值都在-1到1之间，通常是32位浮点
            if (maxValue <= 1 && minValue >= -1) {
                return '32位 (浮点)';
            }
            return '16位 (整数)';
        }

        /**
         * 获取频率数据（使用FFT分析）
         */
        function getFrequencyData(audioBuffer, sampleRate) {
            const channelData = audioBuffer.getChannelData(0);
            const fftSize = 2048;
            const nyquist = sampleRate / 2;
            
            // 使用简单的FFT分析（采样分析）
            const sampleLength = Math.min(channelData.length, sampleRate * 1); // 分析前1秒
            const samples = channelData.slice(0, sampleLength);
            
            // 计算频率范围（通过零交叉点估算）
            let zeroCrossings = 0;
            let maxAmp = 0;
            let minAmp = 0;
            
            for (let i = 1; i < samples.length; i++) {
                if ((samples[i-1] >= 0 && samples[i] < 0) || (samples[i-1] < 0 && samples[i] >= 0)) {
                    zeroCrossings++;
                }
                if (samples[i] > maxAmp) maxAmp = samples[i];
                if (samples[i] < minAmp) minAmp = samples[i];
            }
            
            // 估算主要频率（通过零交叉点）
            const estimatedFreq = (zeroCrossings / 2) / (sampleLength / sampleRate);
            
            // 计算频率范围（基于采样率）
            const maxFreq = Math.min(nyquist, estimatedFreq * 2);
            const minFreq = Math.max(20, estimatedFreq * 0.1); // 人耳可听范围约20Hz-20kHz
            
            return {
                dominantFreq: estimatedFreq > 0 && estimatedFreq < nyquist ? estimatedFreq : null,
                maxFreq: maxFreq,
                minFreq: minFreq,
                nyquist: nyquist
            };
        }

        /**
         * 绘制波形图
         */
        function drawWaveform(audioBuffer) {
            const canvas = waveformCanvas;
            const ctx = canvas.getContext('2d');
            
            // 确保canvas有正确的尺寸
            const containerWidth = canvas.parentElement.offsetWidth;
            const width = canvas.width = containerWidth - 40; // 减去padding
            const height = canvas.height = 200;
            
            // 设置canvas的显示尺寸
            canvas.style.width = width + 'px';
            canvas.style.height = height + 'px';

            ctx.clearRect(0, 0, width, height);
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, width, height);

            const channelData = audioBuffer.getChannelData(0);
            const step = Math.ceil(channelData.length / width);
            const amp = height / 2;

            // 绘制波形
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 1.5;
            ctx.beginPath();

            // 使用更高效的绘制方法
            let maxValue = 0;
            let minValue = 0;
            const samplesPerPixel = Math.max(1, Math.floor(channelData.length / width));
            
            for (let i = 0; i < width; i++) {
                const start = Math.floor(i * step);
                const end = Math.min(start + samplesPerPixel, channelData.length);
                
                // 计算这个像素范围内的最大值和最小值
                let max = 0;
                let min = 0;
                for (let j = start; j < end; j++) {
                    const value = channelData[j];
                    if (value > max) max = value;
                    if (value < min) min = value;
                }
                
                const topY = amp + (max * amp * 0.8);
                const bottomY = amp + (min * amp * 0.8);
                
                if (i === 0) {
                    ctx.moveTo(i, topY);
                } else {
                    ctx.lineTo(i, topY);
                }
                
                // 绘制垂直线连接上下峰值
                if (max !== min) {
                    ctx.moveTo(i, topY);
                    ctx.lineTo(i, bottomY);
                }
            }

            ctx.stroke();

            // 绘制中心线
            ctx.strokeStyle = '#ccc';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(0, amp);
            ctx.lineTo(width, amp);
            ctx.stroke();
        }

        /**
         * 格式化时长
         */
        function formatDuration(seconds) {
            const hours = Math.floor(seconds / 3600);
            const minutes = Math.floor((seconds % 3600) / 60);
            const secs = Math.floor(seconds % 60);
            
            if (hours > 0) {
                return `${hours}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
            }
            return `${minutes}:${secs.toString().padStart(2, '0')}`;
        }

        /**
         * 显示音频信息卡片
         */
        function displayAudioInfo(infoArray) {
            audioInfoGrid.innerHTML = infoArray.map(info => `
                <div class="info-card">
                    <div class="info-label">${info.label}</div>
                    <div class="info-value">${info.value}</div>
                </div>
            `).join('');
        }

        /**
         * 显示音频错误信息
         */
        function showAudioError(message) {
            audioInfoGrid.innerHTML = `<div class="error">${message}</div>`;
        }

        /**
         * 重置音频分析
         */
        function resetAudioAnalysis() {
            audioPreviewSection.classList.remove('active');
            audioFileInput.value = '';
            audioPlayer.innerHTML = '';
            audioInfoGrid.innerHTML = '';
            waveformContainer.style.display = 'none';
            const ctx = waveformCanvas.getContext('2d');
            ctx.clearRect(0, 0, waveformCanvas.width, waveformCanvas.height);
        }
    </script>
</body>
</html>
